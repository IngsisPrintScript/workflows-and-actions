name: Publish Java Modules

on:
  workflow_call:
    inputs:
      java-version:
        type: string
        default: "21"
      environment:
        description: 'Deployment Environment'
        required: false
        default: 'development'
        type: string
      service_name:
        description: 'Service Name to deploy'
        required: false
        type: string
      image_route:
        description: 'Docker Image Route'
        required: false
        type: string

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    outputs:
      azure_rg: ${{ steps.set-deploy-vars.outputs.azure_rg }}
      azure_vm: ${{ steps.set-deploy-vars.outputs.azure_vm }}
      target_ip: ${{ steps.set-deploy-vars.outputs.target_ip }}
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: ${{ inputs.java-version }}

      - name: Make gradlew executable
        run: chmod +x gradlew

      - name: Publish
        run: ./gradlew publish
        env:
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Azure Login (production)
        if: ${{ inputs.environment == 'production' }}
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_PROD }}

      - name: Azure Login (development)
        if: ${{ inputs.environment == 'development' }}
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_DEV }}
            
      - name: Set deploy variables (prod/dev)
        id: set-deploy-vars
        run: |
          if [ "${{ inputs.environment }}" = "production" ]; then
            echo "azure_rg=${{ secrets.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
            echo "azure_vm=${{ secrets.AZURE_VM_NAME_PROD }}" >> $GITHUB_OUTPUT
            echo "target_ip=${{ secrets.IP_PROD }}" >> $GITHUB_OUTPUT
          else
            echo "azure_rg=${{ secrets.AZURE_RESOURCE_GROUP }}" >> $GITHUB_OUTPUT
            echo "azure_vm=${{ secrets.AZURE_VM_NAME_DEV }}" >> $GITHUB_OUTPUT
            echo "target_ip=${{ secrets.IP_DEV }}" >> $GITHUB_OUTPUT
          fi
      - name: Encender la Máquina Virtual
        run: |
          az vm start --resource-group "${{ steps.set-deploy-vars.outputs.azure_rg }}" --name "${{ steps.set-deploy-vars.outputs.azure_vm }}" || true

  deploy-to-dev:
    name: Deploy to Development VM
    runs-on: ubuntu-latest
    needs: build-and-publish
    if: ${{ inputs.environment == 'development' }}

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Add dev SSH key
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.PRIVATE_KEY_DEV }}

      - name: Deploy Specific Service to Dev VM
        run: |
          # If no service_name was provided, skip gracefully (avoid job being Skipped)
          if [ -z "${{ inputs.service_name }}" ]; then
            echo "inputs.service_name not provided — skipping deploy-to-dev job."
            exit 0
          fi

          IP_ADDRESS=${{ needs.build-and-publish.outputs.target_ip }}

          echo "Waiting for the VM to enable the port 22..."
          
          for i in {1..30}; do
            if nc -z $IP_ADDRESS 22; then
              echo "SSH available"
              break
            fi
            echo "Retry SSH attempt $i"
            sleep 5
          done
          
          echo "connecting by SSH"
          
          ssh -o StrictHostKeyChecking=no ${{ secrets.USER }}@$IP_ADDRESS << 'EOF'
            set -e
            echo "Entering infra directory"
            cd infra-ingsis || exit 1

            echo "Log in to Docker inside the VM"
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            echo "Pull the latest changes from the repository"
            docker pull ${{ inputs.image_route }}

            echo "Pull the latest image for a specific service"
            docker compose -f docker-compose.dev.yml up -d ${{ inputs.service_name }}

          EOF

  deploy-to-prod:
    name: Deploy to Production VM
    runs-on: ubuntu-latest
    needs: build-and-publish
    if: ${{ inputs.environment == 'production' }}
  
    steps:
      - name: Check out code
        uses: actions/checkout@v4
  
      - name: Add prod SSH key
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.PRIVATE_KEY_PROD }}
  
      - name: Deploy to Production VM
        run: |
          IP_ADDRESS=${{ needs.build-and-publish.outputs.target_ip }}
  
          echo "Waiting for the production VM to enable the port 22..."
          for i in {1..30}; do
            if nc -z $IP_ADDRESS 22; then
              echo "SSH available"
              break
            fi
            echo "Retry SSH attempt $i"
            sleep 5
          done
  
          echo "connecting by SSH to production"
  
          ssh -o StrictHostKeyChecking=no ${{ secrets.USER }}@$IP_ADDRESS << 'EOF'
            set -e
            echo "Entering infra directory"
            cd infra-ingsis || exit 1
  
            echo "Log in to Docker inside the VM"
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
  
            if [ -n "${{ inputs.image_route }}" ]; then
              echo "Pulling image: ${{ inputs.image_route }}"
              docker pull ${{ inputs.image_route }}
            fi
  
            # If a specific service was requested, deploy only that service; otherwise deploy full prod compose
            if [ -n "${{ inputs.service_name }}" ]; then
              echo "Deploying specific production service: ${{ inputs.service_name }}"
              docker compose -f docker-compose.prod.yml up -d ${{ inputs.service_name }}
            else
              echo "Deploying full production stack"
              docker compose -f docker-compose.prod.yml pull || true
              docker compose -f docker-compose.prod.yml up -d
            fi
  
            echo "Production deploy finished"
  
          EOF
